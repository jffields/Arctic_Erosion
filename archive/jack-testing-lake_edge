/**** Start of imports. If edited, may not auto-convert in the playground. ****/
var lat67 = /* color: #ff0000 */ee.Geometry.LineString(
        [[-139.9739142314343, 67.57763006526794],
         [-125.58889654024293, 67.53463809829742]]),
    WesternMack_1 = 
    /* color: #d63000 */
    /* shown: false */
    ee.Geometry.Polygon(
        [[[-136.6456709949952, 69.08700872525338],
          [-135.9095870106202, 67.87016851592068],
          [-139.8097334949952, 65.58436510570839],
          [-137.7223311512452, 64.72117178492286],
          [-137.0961104481202, 64.18582131453974],
          [-132.86735897662507, 64.13488777854788],
          [-132.14226132037507, 63.96663147147016],
          [-131.72478085162507, 63.62706112028824],
          [-132.16423397662507, 61.21772241622296],
          [-130.81291561725007, 58.961706898233146],
          [-127.73674374225007, 56.99327089862608],
          [-126.27556210162507, 55.547683741517396],
          [-124.39450906519401, 55.18418223783264],
          [-123.46067117456901, 54.82504107514072],
          [-122.66965554956901, 54.57108866017406],
          [-119.70334695581901, 53.55889196832195],
          [-117.87961648706901, 52.48844832964847],
          [-115.04514383081901, 52.94100627077756],
          [-112.71604226831901, 54.187173343213814],
          [-111.51853250269401, 55.259381607205],
          [-109.68381570581901, 55.781807596214904],
          [-107.81613992456901, 56.79995924397231],
          [-107.93698953394401, 57.337475413529546],
          [-110.2660286621488, 58.19765033824793],
          [-110.6780159668363, 58.461542875776566],
          [-110.7823860840238, 58.6463837443152],
          [-110.87851645511755, 58.64209618896625],
          [-111.02133872074255, 58.742002033794655],
          [-111.0185921387113, 59.54630702154173],
          [-112.3589241699613, 60.540548039770066],
          [-113.11835410160192, 61.29017605178613],
          [-113.56879355472692, 61.34158994661358],
          [-113.66217734378942, 61.31259760425681],
          [-114.01648642582067, 60.892299219090994],
          [-114.63446738285192, 60.8695777282006],
          [-114.93109824222692, 60.858879663748255],
          [-115.15082480472692, 60.79997622390134],
          [-116.18903281253942, 60.90832818122992],
          [-116.83447958988317, 61.12393190089451],
          [-117.7971565918363, 61.64517054926209],
          [-119.22054667045435, 62.47716940751586],
          [-119.90169901420435, 62.750060973609536],
          [-122.31319803764185, 62.69467530114029],
          [-122.99600661276838, 63.55539257222384],
          [-124.15231764792463, 64.60551065147534],
          [-123.80075514792463, 64.79331762591438],
          [-123.62772047995588, 64.95425769744203],
          [-123.33246291159651, 65.04943298104435],
          [-123.51511061667463, 65.15811986175466],
          [-124.08509852381793, 65.23314032381094],
          [-125.22767664881793, 65.83822432510175],
          [-126.28236414881793, 66.43049026853159],
          [-127.64673126694969, 66.52074455978627],
          [-128.20909393784814, 66.45911486041581],
          [-130.0117241586976, 67.33934298019352],
          [-130.9180962290101, 67.55214316628319],
          [-131.2312065805726, 67.52695949984033],
          [-131.7200981821351, 67.47230296197807],
          [-132.9066216196351, 67.30121806529371],
          [-133.3790337290101, 67.54165322583393],
          [-133.3131157602601, 67.75473063347964],
          [-133.77462392248088, 68.11158271667242],
          [-133.64004140294963, 68.54969176170329],
          [-133.83779530919963, 69.47427105762804],
          [-135.28799062169963, 69.73462108489251]]]),
    MERIT_Unioned_Streams = ee.FeatureCollection("users/jordanffieldsgr/ArcticCarbon/MERIT_Unioned_Streams"),
    MERIT_VF_Ord7 = ee.FeatureCollection("users/jordanffieldsgr/ArcticCarbon/MERIT_Vectors_filtered_Ord7"),
    Mack_GT_sites = ee.FeatureCollection("users/jordanffieldsgr/ArcticCarbon/Mack_Groundtruth_Sites"),
    New_cpixel_AOI = 
    /* color: #5220d6 */
    /* shown: false */
    ee.Geometry.Polygon(
        [[[-133.965367054451, 67.70163967529295],
          [-133.954379343736, 67.80978401066871],
          [-133.89394771213844, 67.86573930174703],
          [-133.9269102520006, 67.93601095480037],
          [-133.80055313545822, 68.01841210695784],
          [-133.73462760090118, 68.07386747444518],
          [-133.72913374855213, 68.09795928576627],
          [-133.67968967043697, 68.10513068405275],
          [-133.65496760960747, 68.11485974236905],
          [-133.64810025240658, 68.15271273813845],
          [-133.7758307448652, 68.16191085922013],
          [-134.24005566052864, 68.20376666906606],
          [-134.1205657436365, 68.26996695929493],
          [-133.92278910214284, 68.39370357428372],
          [-133.94751102539507, 68.4810282009582],
          [-134.0230506308254, 68.55446250501647],
          [-134.10408406873006, 68.67116123899149],
          [-134.17000968094726, 68.71258563235436],
          [-134.41173717809684, 68.83739068478991],
          [-134.6520915792932, 68.95804575261798],
          [-134.7138970909606, 69.00139938646362],
          [-134.91716807244248, 68.97480603220676],
          [-134.96798568395178, 68.94077894009473],
          [-134.87047034533376, 68.89236035257777],
          [-134.6630786995987, 68.76527084631734],
          [-134.46237492964588, 68.6274852394607],
          [-134.39507573397157, 68.4863954284469],
          [-134.52555303519972, 68.27385905858004],
          [-134.61026458431925, 68.12065213970762],
          [-134.67033130647616, 68.01998013226864],
          [-134.69642647659177, 67.90764371076529],
          [-134.76149574841546, 67.69742465452227],
          [-134.93957242845428, 67.59947578660257],
          [-134.93290087421306, 67.48577873034489],
          [-134.61577674132107, 67.58020599374713],
          [-134.39367950440356, 67.6300859527481]]]),
    Good_Thiessens = ee.FeatureCollection("users/jordanffieldsgr/ArcticCarbon/Good_Thiessens_3"),
    High_Relief_Region = ee.FeatureCollection("users/jordanffieldsgr/ArcticCarbon/High_Relief_Region"),
    High_Relief_North = ee.FeatureCollection("users/jordanffieldsgr/ArcticCarbon/High_Relief_North"),
    High_Relief_South = ee.FeatureCollection("users/jordanffieldsgr/ArcticCarbon/High_Relief_South"),
    cpixel_Masks = ee.ImageCollection("users/jordanffieldsgr/ArcticCarbon/cpixel_Masks_Sept23"),
    Mack_SlopeMask = ee.Image("users/jordanffieldsgr/ArcticCarbon/Mack_SlopeMask"),
    geometry = 
    /* color: #98ff00 */
    /* shown: false */
    ee.Geometry.Polygon(
        [[[-134.25296708445927, 67.76883881069324],
          [-134.26189347606083, 67.75974445131472],
          [-134.27837296824833, 67.75870487111538],
          [-134.27425309520146, 67.74674638297918],
          [-134.27219315867802, 67.72385226783172],
          [-134.18086930613896, 67.73452162428339],
          [-134.18979569774052, 67.7446660229989],
          [-134.19185563426396, 67.7698779412387],
          [-134.2550270209827, 67.77611175627837]]]),
    CaseStudy2 = 
    /* color: #8b64d6 */
    /* shown: false */
    ee.Geometry.MultiPoint(
        [[-134.26634793555, 66.54626062045898],
         [-134.26669982134243, 66.48441352906653],
         [-134.02809050737758, 66.48441352906653],
         [-134.02809050737758, 66.54604906913822]]),
    CaseStudy3 = 
    /* color: #fd67ff */
    /* shown: false */
    ee.Geometry.MultiPoint(
        [[-123.51991377179301, 61.098111479413284],
         [-123.11891279523051, 61.098111479413284],
         [-123.11891279523051, 60.9978962705192],
         [-123.52094374005473, 60.9978962705192]]);
/***** End of imports. If edited, may not auto-convert in the playground. *****/
// load pre-generated assets: rivers, segment buffers, and re-defined project area
// this is much faster then attempting to generate them from scratch
//Map.addLayer(MERIT_VF_Ord7, {}, "MERIT STREAMS"); 
//print(MERIT_VF_Ord7);
//print(MERIT_Unioned_Streams, "Merit Unioned Streams");
//Map.addLayer(MERIT_Unioned_Streams, {}, "MERIT UNIONED STREAMS"); 
// Map.addLayer(Mack_GT_sites, {}, "GT Sites")
//Map.addLayer(WesternMack_1, {}, 'Western Mack 1'); 
Map.addLayer(Good_Thiessens, {}, 'Good Thiessens'); 


//// TOGGLES FOR EXPORTS /////
var tFirst = 0; // change this for exports
var tEnd = tFirst + 55; 

// FUNCTIONS

// Defining function to remove Speckle from water occurence sensing code
var removeSpeckle = function(image){
  var imageSel = image.select(['Green', 'NIR']);
  //var replaceNegatives = imageSel.lt(0), 1); // trying to replace .where(), which is memory intensive
  var replaceNegatives = imageSel.where(imageSel.lt(0), 1);
  var returnImage = image.addBands(replaceNegatives, null, true);
  return returnImage;
  };
  
////// RENAME BANDS ///////
//Function to get and rename bands all landsat 8 collection 2 images.
function renameOli(img) {
  return img.select(
                  ['SR_B2', 'SR_B3', 'SR_B4', 'SR_B5', 'SR_B6', 'SR_B7'], //'SR_QA_AEROSOL',  'QA_PIXEL' -- Taking these out to save memory 9/23/23
                  ['Blue', 'Green', 'Red', 'NIR', 'SWIR1', 'SWIR2']) //'SR_QA_AEROSOL', 'pixel_qa' -- Taking these out to save memory 9/23/23
            .copyProperties(img, img.propertyNames()); 
}

// Functions to rename bands in LS5 and LS7 Collection 2 images.
function renameEtm(img) {
  return img.select(
                  ['SR_B1', 'SR_B2', 'SR_B3', 'SR_B4', 'SR_B5', 'SR_B7'], // ,'QA_PIXEL' -- Taking this out to save memory 9/23/23
                  ['Blue', 'Green', 'Red', 'NIR', 'SWIR1', 'SWIR2']) // ,'pixel_qa' -- Taking this out to save memory 9/23/23
            .copyProperties(img, img.propertyNames()); 
}

// Function for masking all pixels in an image except water pixels
// using WRI and band-based filters
var waterOnly = function(image){ 
  var land = image.select('SWIR2').lt(10909.09).rename('land'); // see doc for notes on this threshold; 10909.09; if we scale bands, this is <0.1
  var cloudFinal = image.select('Blue').add(image.select('Green'))
      .lt(22545.45).rename('cloudFinal'); // see docs for notes on this threshold; 15272.73; if we scale bands, this is <0.22
  
  // calculate WRI (water detection algorithm)
  var GREEN = image.select('Green');
  var RED = image.select('Red');
  var NIR = image.select('NIR');
  var SWIR1 = image.select('SWIR1');
  var WRI = (GREEN.add(RED)).divide(NIR.add(SWIR1)); 
  
  // save the image's original mask (edges and/or LS7 stripes) for use later
  // can select any band, rename for clarity
  var orig_mask = image.unmask(-1).gte(0).select(["Green"],["orig_mask"]);
  
  return image.addBands(ee.Image(1).rename('water'))
              .updateMask(cloudFinal)
              .updateMask(land)
              .updateMask(Mack_SlopeMask)
              .updateMask(WRI.gt(1))
              .addBands(WRI)
              .addBands(orig_mask);
};


// Function to unmask the image, setting valid non-water pixels = 0 and masking invalid pixels
// invalid pixels are those masked in the original image
var getUnmask = function(image){
  return(image.unmask(0).mask(image.select("orig_mask")));
  };


// MAIN FUNCTION FOR ANALYSIS
// For a given set of years:
// Of all selected images, only select water pixels
// Result is mean water occurrence (1 = always water, 0 = never water)
var getWater_years = function(year){
  var startDate = ee.Date.fromYMD(year, 1, 1);
  var endDate = startDate.advance(2, 'year'); // rolling 2 year time window
    
  // get the right connected pixel mask
  var connectedMask = cpixel_Masks.filter(ee.Filter.eq('year', year)).first(); // only one image should match
 
  var water = allImages_NEW
            .filterDate(startDate, endDate)
            .map(waterOnly)       // mask out non-water pixels
            .map(getUnmask)       // unmask the image to set valid non-water pixels = 0
            .select('water')      // select only the water occurrence band
            .mean()            // compute the mean water occurrence for each pixel across all images
            .gt(0.20)  ;       //threshold for % of time (images) that a pixel must be water to be counted as water (added by JF 04/11/23)
            
  return ee.Image(water
          .updateMask(water) // any pixels that are water in less than X% (currently 20%) of images don't count as water
          .updateMask(connectedMask) // mask out any lake areas as determined by connected pixels
          .set('start_year',year)
          .rename('water'));
  };
 
 ///// NDVI ///// 
//create function to calc NDVI
function NDVI_Calc(image) {
  // Claculate NDVI using normalizedDifference([list of bandname]).rename()
  var NDVI = image.normalizedDifference(['NIR','Red']).rename('NDVI');
  //Add the NDVI band to the image and return
  return image.addBands([NDVI]);
}



// BIG LOOP (uncomment for batched exports)

// for(var i = 0; i < 50; i++) {
//   var tFirst = (i * 55)
//   var tEnd = (tFirst + 55);


// filter thiessen polygons for project AOI to exclude unwanted polys (covering lake areas)
var thiessen_polys = Good_Thiessens;
var tlist_ALL = thiessen_polys.aggregate_array('point_ID'); 
var tlist_select = tlist_ALL.slice(tFirst,tEnd); 
//print(tlist_select);
var thiessen_polys = thiessen_polys.filter(ee.Filter.inList('point_ID', tlist_select)); 
//print(thiessen_polys); 

///////////////////////////////////////////////////////////////////////////////////////////////
                /////// PREPARE IMAGE COLLECTIONS FOR ANALYSIS ///////
///////////////////////////////////////////////////////////////////////////////////////////////

//// IMPORT IMAGES ////
// COLLECTION 2 DATA //
var ls5new = ee.ImageCollection('LANDSAT/LT05/C02/T1_L2')
                                .filter(ee.Filter.bounds(WesternMack_1)) // change this if re-defining project area // was "WesternMack_1 //thiessen_polys.geometry()
                                .filter(ee.Filter.dayOfYear(151,288))
                                .filterMetadata('CLOUD_COVER', 'less_than', 20);
var ls7new = ee.ImageCollection('LANDSAT/LE07/C02/T1_L2')
                                .filter(ee.Filter.bounds(WesternMack_1)) // change this if re-defining project area
                                .filter(ee.Filter.dayOfYear(151,288))
                                .filterMetadata('CLOUD_COVER', 'less_than', 20);
                                
var ls8new = ee.ImageCollection("LANDSAT/LC08/C02/T1_L2") //new
                                .filter(ee.Filter.bounds(WesternMack_1)) // change this if re-defining project area
                                .filter(ee.Filter.dayOfYear(151,288))
                                .filterMetadata('CLOUD_COVER', 'less_than', 20);



// Filter NEW (C2 instead of C1) collections and prepare them for merging.
var etmCol_new = ls7new.map(renameEtm); //(prepETM);
var tmCol_new = ls5new.map(renameEtm);   //(prepETM);
var oliCol_new = ls8new.map(renameOli);      //(prepOli);

// Merge the collections.
var allImages_tm_new = etmCol_new
                      .merge(tmCol_new)
                      .map(removeSpeckle);
var allImages_NEW = oliCol_new
                      .merge(allImages_tm_new);

///// END IMAGE PREP /////

/// FUNCTIONS FOR ANALYSIS ///

// calculate per-pixel NDVI for all images
var allImages_NEW = allImages_NEW.map(NDVI_Calc); 

// function to calculate mean NDVI value per pixel
// over entire study area, in two year rolling windows
var getNDVI_years = function(year){
  var startDate = ee.Date.fromYMD(year, 1, 1);
  var endDate = startDate.advance(2, 'year'); // rolling 2 year time window
  var meanNDVI = allImages_NEW
            .filterDate(startDate, endDate)
            .select('NDVI')
            .mean(); // This returns the mean value of each pixel, not mean for entire image 
  return ee.Image(meanNDVI).set('start_year',year)
};


//// PERFORM ANALYSES ////
//// CALCULATE WATER OCCURRENCE FOR SELECTED FIVE-YEAR PERIODS ////

// Construct list 1985-2023 -- all years for which we have data
var waterYear = ee.List.sequence(1985,2023,1);


// Select water/NDVI pixels for each year
var waterYear_long = ee.ImageCollection(waterYear.map(getWater_years));
var ndviYear_long = ee.ImageCollection(waterYear.map(getNDVI_years)); 
//print(waterYear_long.first(), "water Year Long check")

// Select water pixels for each year starting in 1990
// we will later do area calculations over a 5 year span, so can't
// perform the first calculation until 1990, when we have 5 years of data
var waterYear_short = waterYear_long.filter(ee.Filter.gte('start_year', 1990)); //when running in blocks, this date = start of waterYear list +5 yrs
var ndviYear_short = waterYear_long.filter(ee.Filter.gte('start_year', 1990)); //when running in blocks, this date = start of waterYear list +5 yrs


// Subtract water occurence of earlier year from more recent year
// results in map of area that changed between land and water
 var getareaChange = function(image){
   var year_sel = ee.Number(image.get('start_year'));
   var year_pre = year_sel.subtract(5);
   var pre_image = ee.Image(waterYear_long
        .filterMetadata('start_year', 'equals', year_pre)
        .first());
   var pre_land = pre_image.gt(0).unmask(0).eq(0);
   var landLost = image.updateMask(pre_land);  //.pixelArea();
   var post_land = image.gt(0).unmask(0).eq(0);
   var landGained = pre_image.updateMask(post_land);  //.pixelArea();
   // return image.addBands(landLost.rename('Land Lost')).addBands(landGained.rename('Land Gained')); // is this better?
   return ee.Image(landLost).rename('Land Lost')
                            .addBands(landGained.rename('Land Gained'));
                            //.addBands(image); // added this 6/22/23 to preserve water band; so 'image' is water in the end of the
                                              // 5yr window (i.e. it is 1990 water for the 1985-1990 period). We use water from the 
                                              // start of the period to normalize so we want to save 'pre_image' here potentially. 
   };

// Generate water occurence difference for each range of years
var mappedArea =  waterYear_short.map(getareaChange);

// Function to count quantity of area change for an image that is a map of area change
// returns feature collection with area lost/gained in each, along with 'MERIT Hydro' raster properties 
/////// NOTE: WHEN RUNNING FOR 'Total Water Area' COMMENT OUT THE AREA LOST/GAINED PROPERTIES HERE AND REMOVE 
/////// THOSE PARAMETERS FROM THE 'GET_EXPORT_PROPS' FUNCTION
var pixelArea = ee.Image.pixelArea();

var areaCount = function(image){
  var start_year = image.get('start_year');
  var image1 = pixelArea.multiply(image);
  //var image1 = pixelArea.updateMask(image);
  var reduced = image1.reduceRegions({
      reducer: ee.Reducer.sum(), // change to .count() if not using the .pixelArea method
      collection: thiessen_polys, // this becomes 'poly' //.limit(50)
      scale: 30,
      crs: image.projection() // exports fail due to memory limits when we specify "EPSG:32610"
    });
    return reduced.map(function(feature){ // map function to generate properties over each feature
      return ee.Feature(feature)
                                .set('start_year', start_year) // For 1990 - 1985, 1990 is the start year
                                .setGeometry(null)
                                .set('latitude', feature.geometry().centroid().coordinates().get(1))
                                .set('longitude', feature.geometry().centroid().coordinates().get(0))
                                .set('Water_Area_km2', ee.Number(feature.get('sum')).divide(1e6)) // when using the .pixelArea() method, converts from m2 to km2
                                //.set('area_gained_km2', ee.Number(feature.get('Land Gained')).divide(1e6)) // when using the .pixelArea() method, converts from m2 to km2
                                //.set('area_lost_km2', ee.Number(feature.get('Land Lost')).divide(1e6)) // when using the .pixelArea() method, converts from m2 to km2
                                //.set('Water_Area_km2', ee.Number(feature.get('count')).multiply(0.0009)) // when using the .count() method -- each Landsat pixel has an area of 0.0009km2
                                //.set('area_gained_km2', ee.Number(feature.get('Land Gained')).multiply(0.0009)) // when using the .count() method 
                                //.set('area_lost_km2', ee.Number(feature.get('Land Lost')).multiply(0.0009)) // when using the .count() method 
                                .set('Polygon_Area_km2', feature.get('Area_km2'))
                                .set('Stream_Order', feature.get('mean'))
                                .set('Flw_Dir', feature.get('dir'))
                                .set('Elv', feature.get('elv'))
                                .set('Thiessen_ID', feature.get('point_ID'))
                                .set('Upstream_Area_km2', feature.get('upa'))
                                .set('Upstream_pix', feature.get('upg'))
                                .set('Hydro_Adj_Elv', feature.get('hnd'))
                                .set('Width', feature.get('wth'))
                                //.set('Length_m', feature.get('length_m'));
                
    });
};

// function to select desired properties for export
var get_export_props = function(feature) {
  return ee.Feature(feature.select(['start_year', 'Water_Area_km2', 'Polygon_Area_km2', 'latitude', 'longitude', 
                                    'Stream_Order', 'Flow_Dir', 'Elv', 'Thiessen_ID', 'Upstream_Area_km2', 
                                    'Upstream_pix', 'Hydro_Adj_Elv', 'Width']));
};

// IMPORTANT: put this in the list above and take out 'area lost/gained' when running/exporting for total water area
// 'area_lost_km2', 'area_gained_km2',


///////////// Calculate PIXELS LOST/GAINED by segment over all years, flatten output, select properties /////////////
// var pixelsChanged = ee.FeatureCollection(mappedArea.map(areaCount)).flatten();

// // get rid of this step?
// var pixelsChanged_to_export = pixelsChanged.map(get_export_props);


//////////// Calculate TOTAL AREA covered by water by segment over all years ////////////////
var totalArea = ee.FeatureCollection(waterYear_long.map(areaCount)).flatten();

var totalArea_to_export = totalArea.map(get_export_props);
//print('Total Area Data:', totalArea_to_export.first());



////// NDVI FUNCTIONS //////

//
 var getNDVI_Change = function(image){
   var year_sel = ee.Number(image.get('start_year'));
   var year_pre = year_sel.subtract(5);
   var pre_image = ee.Image(ndviYear_long
        .filterMetadata('start_year', 'equals', year_pre)
        .first());
   var ndviChange = image.divide(pre_image); // making a ratio of later NDVI over earlier NDVI:
   // 0-1 means browning; 1 means no change; >1 means greening
   return ee.Image(ndviChange).rename('NDVI Ratio').set('Year', year_sel); 
 };
 
// Generate water occurence difference for each range of years
var ndviDiff =  ndviYear_short.map(getNDVI_Change);
//print('NDVI Diff', ndviDiff.limit(2)); 

// Function to get mean NDVI value in each Thiessen Polygon
// returns feature collection with NDVI Ratio in each, along with 'MERIT Hydro' raster properties 
var ndviReduce = function(image){
  var Year = image.get('Year');
  var reduced = image.reduceRegions({
      reducer: ee.Reducer.mean(),
      collection: thiessen_polys, //.limit(50)
      scale: 30
      //crs: image.projection() //'EPSG:32610',
      //tileScale: 16 // otherwise exceeds memory limit
    });
    return reduced.map(function(feature){ // map function to generate properties over each image
      return ee.Feature(feature)
                                .set('Year', Year) // For 1990 - 1985, 1990 is the start year
                                // .setGeometry(null)
                                // .set('latitude', feature.geometry().centroid().coordinates().get(1))
                                // .set('longitude', feature.geometry().centroid().coordinates().get(0))
                                .set('NDVI_Ratio', ee.Number(feature.get('mean')))
                                //.set('Polygon_Area_km2', feature.get('Area_km2'))
                                // .set('Stream_Order', feature.get('mean'))
                                // .set('Flw_Dir', feature.get('dir'))
                                // .set('Elv', feature.get('elv'))
                                .set('Thiessen_ID', feature.get('point_ID'))
                                // .set('Upstream_Area_km2', feature.get('upa'))
                                // .set('Upstream_pix', feature.get('upg'))
                                // .set('Hydro_Adj_Elv', feature.get('hnd'))
                                // .set('Width', feature.get('wth'))
                                //.set('Length_m', feature.get('length_m'));
                
    });
};

// function to select desired properties for export
var get_export_props = function(feature) {
  return ee.Feature(feature.select(['Year', 'NDVI_Ratio', 'Thiessen_ID']));
};

// 'Polygon_Area_km2', 'latitude', 'longitude', 
                                    // 'Stream_Order', 'Flow_Dir', 'Elv', 'Upstream_Area_km2', 
                                    // 'Upstream_pix', 'Hydro_Adj_Elv', 'Width'

// Calculate change in NDVI by segment over all years, flatten output, select properties
var ndviData = ee.FeatureCollection(ndviDiff.map(ndviReduce)).flatten();
//print('NDVI Data:', ndviData.limit(2)); 

// Map export Properties fxn
var ndviExport = ndviData.map(get_export_props);
//print('NDVI export Data:', ndviExport.first()); 



////////// TROUBLESHOOTING CODE BLOCK ////////////////
var problem_ids = ee.List([388852, 1486504, 2713721, 5356155, 6647545, 7952461, 8134763,
                           8256392, 8864240, 9914455, 176519]);

var problem_polys = Good_Thiessens.filter(ee.Filter.inList('point_ID', problem_ids));

// did area estimation for 556931
var target = ee.Feature(Good_Thiessens.filter(ee.Filter.eq('point_ID', 7879505)).first());
//Map.addLayer(target, {}, "target poly")
//Map.addLayer(problem_polys, {}, "Bad Thiessens");

//print("actual area for real this time: ", target.geometry().area().divide(1e6));

var gwy = getWater_years(1990);
var gwy2 = getWater_years(1985);

Map.addLayer(gwy2, {min: 0, max: 1, palette: ['#f3e79b']}, "gwy 2"); // yellow
Map.addLayer(gwy, {min: 0, max: 1, palette: ['#f8a07e']}, "gwy"); // red

var landsat_vis = {
  bands: ['Red', 'Green', 'Blue'], 
  min: 7000,
  max: 11000,
};

//print("gwy img projection: ", gwy2.projection());
// calculate water area in target using count
var area0 = gwy2.reduceRegion({
  reducer: ee.Reducer.count(),
  geometry: ee.FeatureCollection(target),
  scale: 30,
  crs: "EPSG:32610"
});
//print("count (CRS): ", ee.Number(area0.get("water")).multiply(0.0009)); // each pixel is 30m

var area1 = gwy2.reduceRegion({
  reducer: ee.Reducer.count(),
  geometry: ee.FeatureCollection(target),
  scale: 30
});
//print("count (no CRS): ", ee.Number(area1.get("water")).multiply(0.0009)); // each pixel is 30m

// calculate water area in target using pixelArea
var pixel_area_img = ee.Image.pixelArea().multiply(gwy2);
var area2 = pixel_area_img.reduceRegion({
  reducer: ee.Reducer.sum(),
  geometry: ee.FeatureCollection(target),
  scale: 30
});
//print("pixelArea: ", ee.Number(area2.get("area")).divide(1e6)); // gives area in sq m

// count disconnected water pixels (lake edge pixels)
var yr = 1985
var img = getWater_years(yr);
var limit = 100;
var cpixel_count = img.connectedPixelCount(limit);
var masked_count = cpixel_count.mask(cpixel_count.lt(limit));

var cpix_mask = cpixel_Masks.filter(ee.Filter.eq('year', 1985)).first();
var cpix_mask2 = cpixel_Masks.filter(ee.Filter.eq('year', 1987)).first();
var cpix_mask3 = cpixel_Masks.filter(ee.Filter.eq('year', 1990)).first();
var cpix_mask4 = cpixel_Masks.filter(ee.Filter.eq('year', 1995)).first();

Map.addLayer(cpix_mask.mask(cpix_mask.eq(0)), {min:0, max:1, opacity:0.75, palette:["green"]}, 'cpixel mask 1985');
Map.addLayer(cpix_mask2.mask(cpix_mask2.eq(0)), {min:0, max:1, opacity:0.75, palette:["yellow"]}, 'cpixel mask 1987');
Map.addLayer(cpix_mask3.mask(cpix_mask3.eq(0)), {min:0, max:1, opacity:0.75, palette:["blue"]}, 'cpixel mask 1990');
Map.addLayer(cpix_mask4.mask(cpix_mask4.eq(0)), {min:0, max:1, opacity:0.75, palette:["red"]}, 'cpixel mask 1995');


var cpix_mosaic = cpixel_Masks.map(function(img){
  var inverted = img.select('water').multiply(-1).rename("quality");
  return img.addBands(inverted);
}).qualityMosaic('quality');

Map.addLayer(cpix_mosaic.mask(cpix_mosaic.eq(0)), {min:0, max:1}, "mosaic");


var counted = masked_count.reduceRegion({
  reducer: ee.Reducer.count(),
  geometry: New_cpixel_AOI,
  scale: 30
  });

// compare disconnected to total

var total_pix = img.reduceRegion({
  reducer: ee.Reducer.count(),
  geometry: New_cpixel_AOI,
  scale: 30
});

var land_lost = ee.Image(mappedArea.filter(ee.Filter.eq('start_year', 1990)).first()).select('Land Lost');
//Map.addLayer(land_lost, {min:0, max:1, palette:["red"]}, "land lost");

var land_lost2 = ee.Image(mappedArea.filter(ee.Filter.eq('start_year', 1995)).first()).select('Land Lost');
//Map.addLayer(land_lost2, {min:0, max:1, palette:["white"]}, "land lost 2");

/*
//////////////// .pixelArea() Test /////////////////


// Create a pixel area image. Pixel values are square meters based on
// a given CRS and scale (or CRS transform).
var pixelArea = ee.Image.pixelArea();

// The default projection is WGS84 with 1-degree scale.
print('Pixel area default projection', pixelArea.projection());

// When inspecting the output in the Code Editor map, the scale of analysis is
// determined by the zoom level. As you zoom in and out, you'll notice that the
// area of the clicked pixel changes. To set a specific pixel scale when
// performing a computation, provide an argument to the `scale` or
// `crsTransform` parameters whenever a function gives you the option.
Map.addLayer(pixelArea, null, 'Pixel area for inspection', false);

// The "area" band produced by the `pixelArea` function can be useful for
// calculating the area of a certain condition of another image. For example,
// here we use the sum reducer to determine the area above 2250m in the North
// Cascades ecoregion, according to a 30m digital elevation model.

// Water Image
var gwy = getWater_years(1989);
Map.addLayer(gwy, {min:0, max:1, palette: ['white', 'Blue']}, 'GWY89'); 
var gwy = getWater_years(1985);
Map.addLayer(gwy, {min:0, max:1, palette: ['white', 'red']}, 'GWY85');


// Apply the high elevation mask to the pixel area image.
var gwy = pixelArea.updateMask(gwy);

// Display the ecoregion and high elevation area.
//Map.setCenter(-134.1713, 67.757, 11);

var gwy_proj = gwy.projection();//.transform (); 
print('gwy projection:', gwy_proj);

// Sum the area of high elevation pixels in the North Cascades ecoregion.
var area = gwy.reduceRegion({
  reducer: ee.Reducer.sum(),
  geometry: Good_Thiessens.filter(ee.Filter.eq('point_ID', 388852)),
  scale: 30,
  crs: gwy.projection(), //'EPSG:32610',   // GWY coordinate reference system
  //crsTransform: [gwy.projection().transform()],  // GWY grid alignment //.getInfo()
  maxPixels: 1e13
});

// Fetch the summed area property from the resulting dictionary and convert
// square meters to square kilometers.
var squareMeters = area.getNumber('area');
var squareKilometers = squareMeters.divide(1e6);

//print('Square meters of water in selected Thiessen', squareMeters);
print('Water area in selected Thiessen w/ .pixelArea', squareKilometers);


//////////////// .pixelArea() Test /////////////////


var img = ee.Image.constant(1)
//print(gwy)
var water_area = gwy.reduceRegions({
      reducer: ee.Reducer.count(),
      collection: Good_Thiessens.filter(ee.Filter.eq('point_ID', 388852)), 
      scale: 30,
      crs: gwy.projection() //'EPSG:32610',
    });
    
var water_area_img = water_area.first();
print('water area img:', water_area_img)
//var water_count = water_area_img.get('count');
//print("Water area in selected Thiessen  w/ .count():", water_count);
print("manually measured water area ", geometry.area().divide(1e6))

var point = ee.Geometry.Point (-134.5072, 68.7526);//(-126.4752, 61.8664);


var pool = allImages_NEW.filterDate('1985-06-01', '2023-10-15') 
                    .filterBounds(point)
                    .sort("SENSING_TIME")
//print("gwy image pool at selected point:", pool)

var pool2 = allImages_NEW.filterDate('2010-01-01', '2021-01-01')
                    .filterBounds(New_cpixel_AOI)
                    .sort("SENSING_TIME")
//print("GWY image pool in entire cpixel AOI", pool2)

////////// END TROUBLESHOOTING CODE BLOCK ////////////////

*/

/////////////// ALL EXPORTS ////////////////////


// Export area lost to drive
// Export.table.toDrive({
//   collection: pixelsChanged_to_export,
//   folder: 'ARCTIC_CARBON',
//   description: 'AreaChanged_'+ 'Thiessens_' + tFirst + '_' + tEnd, // to calculate a different year range
//                                           // you change waterYear_short  
//   fileNamePrefix: 'AreaChanged_'+ 'Thiessens_' + tFirst + '_' + tEnd,
//   fileFormat: 'CSV'
// });



//Export Total Water Area
Export.table.toDrive({
  collection: totalArea_to_export,
  folder: 'ARCTIC_CARBON',
  description: 'TotalArea_' + 'Thiessens_' + tFirst + '_' + tEnd,
  fileNamePrefix: 'TotalArea_' + 'Thiessens_' + tFirst + '_' + tEnd,
  fileFormat: 'CSV'
});


//Export NDVI Ratio for each Thiessen Polygon
// Export.table.toDrive({
//   collection: ndviExport,
//   folder: 'ARCTIC_CARBON',
//   description: 'ndviRatio_' + 'Thiessens_' + tFirst + '_' + tEnd,
//   fileNamePrefix: 'ndviRatio_' + 'Thiessens_' + tFirst + '_' + tEnd,
//   fileFormat: 'CSV'
// });


// Calculate total area of Thiessen Polygons (MODIFY)
// var thiessenArea = ee.FeatureCollection(Good_Thiessens.map(areaCount)).flatten();
// var totalArea_to_export = totalArea.map(get_export_props);

/////////////// END EXPORTS ////////////////////

//} // END FOR LOOP from the very top


