/**** Start of imports. If edited, may not auto-convert in the playground. ****/
var lat67 = /* color: #ff0000 */ee.Geometry.LineString(
        [[-139.9739142314343, 67.57763006526794],
         [-125.58889654024293, 67.53463809829742]]),
    WesternMack_1 = 
    /* color: #d63000 */
    /* shown: false */
    ee.Geometry.Polygon(
        [[[-136.6456709949952, 69.08700872525338],
          [-135.9095870106202, 67.87016851592068],
          [-139.8097334949952, 65.58436510570839],
          [-137.7223311512452, 64.72117178492286],
          [-137.0961104481202, 64.18582131453974],
          [-132.86735897662507, 64.13488777854788],
          [-132.14226132037507, 63.96663147147016],
          [-131.72478085162507, 63.62706112028824],
          [-132.16423397662507, 61.21772241622296],
          [-130.81291561725007, 58.961706898233146],
          [-127.73674374225007, 56.99327089862608],
          [-126.27556210162507, 55.547683741517396],
          [-124.39450906519401, 55.18418223783264],
          [-123.46067117456901, 54.82504107514072],
          [-122.66965554956901, 54.57108866017406],
          [-119.70334695581901, 53.55889196832195],
          [-117.87961648706901, 52.48844832964847],
          [-115.04514383081901, 52.94100627077756],
          [-112.71604226831901, 54.187173343213814],
          [-111.51853250269401, 55.259381607205],
          [-109.68381570581901, 55.781807596214904],
          [-107.81613992456901, 56.79995924397231],
          [-107.93698953394401, 57.337475413529546],
          [-110.2660286621488, 58.19765033824793],
          [-110.6780159668363, 58.461542875776566],
          [-110.7823860840238, 58.6463837443152],
          [-110.87851645511755, 58.64209618896625],
          [-111.02133872074255, 58.742002033794655],
          [-111.0185921387113, 59.54630702154173],
          [-112.3589241699613, 60.540548039770066],
          [-113.11835410160192, 61.29017605178613],
          [-113.56879355472692, 61.34158994661358],
          [-113.66217734378942, 61.31259760425681],
          [-114.01648642582067, 60.892299219090994],
          [-114.63446738285192, 60.8695777282006],
          [-114.93109824222692, 60.858879663748255],
          [-115.15082480472692, 60.79997622390134],
          [-116.18903281253942, 60.90832818122992],
          [-116.83447958988317, 61.12393190089451],
          [-117.7971565918363, 61.64517054926209],
          [-119.22054667045435, 62.47716940751586],
          [-119.90169901420435, 62.750060973609536],
          [-122.31319803764185, 62.69467530114029],
          [-122.99600661276838, 63.55539257222384],
          [-124.15231764792463, 64.60551065147534],
          [-123.80075514792463, 64.79331762591438],
          [-123.62772047995588, 64.95425769744203],
          [-123.33246291159651, 65.04943298104435],
          [-123.51511061667463, 65.15811986175466],
          [-124.08509852381793, 65.23314032381094],
          [-125.22767664881793, 65.83822432510175],
          [-126.28236414881793, 66.43049026853159],
          [-127.64673126694969, 66.52074455978627],
          [-128.20909393784814, 66.45911486041581],
          [-130.0117241586976, 67.33934298019352],
          [-130.9180962290101, 67.55214316628319],
          [-131.2312065805726, 67.52695949984033],
          [-131.7200981821351, 67.47230296197807],
          [-132.9066216196351, 67.30121806529371],
          [-133.3790337290101, 67.54165322583393],
          [-133.3131157602601, 67.75473063347964],
          [-133.77462392248088, 68.11158271667242],
          [-133.64004140294963, 68.54969176170329],
          [-133.83779530919963, 69.47427105762804],
          [-135.28799062169963, 69.73462108489251]]]),
    Thiessen_300m = ee.FeatureCollection("users/jordanffieldsgr/ArcticCarbon/Thiessen_Polygons_300m"),
    MERIT_Unioned_Streams = ee.FeatureCollection("users/jordanffieldsgr/ArcticCarbon/MERIT_Unioned_Streams"),
    MERIT_VF_Ord7 = ee.FeatureCollection("users/jordanffieldsgr/ArcticCarbon/MERIT_Vectors_filtered_Ord7"),
    Mack_GT_sites = ee.FeatureCollection("users/jordanffieldsgr/ArcticCarbon/Mack_Groundtruth_Sites"),
    New_cpixel_AOI = 
    /* color: #5220d6 */
    /* shown: false */
    ee.Geometry.Polygon(
        [[[-133.965367054451, 67.70163967529295],
          [-133.954379343736, 67.80978401066871],
          [-133.89394771213844, 67.86573930174703],
          [-133.9269102520006, 67.93601095480037],
          [-133.80055313545822, 68.01841210695784],
          [-133.73462760090118, 68.07386747444518],
          [-133.72913374855213, 68.09795928576627],
          [-133.67968967043697, 68.10513068405275],
          [-133.65496760960747, 68.11485974236905],
          [-133.64810025240658, 68.15271273813845],
          [-133.7758307448652, 68.16191085922013],
          [-134.24005566052864, 68.20376666906606],
          [-134.1205657436365, 68.26996695929493],
          [-133.92278910214284, 68.39370357428372],
          [-133.94751102539507, 68.4810282009582],
          [-134.0230506308254, 68.55446250501647],
          [-134.10408406873006, 68.67116123899149],
          [-134.17000968094726, 68.71258563235436],
          [-134.41173717809684, 68.83739068478991],
          [-134.6520915792932, 68.95804575261798],
          [-134.7138970909606, 69.00139938646362],
          [-134.91716807244248, 68.97480603220676],
          [-134.96798568395178, 68.94077894009473],
          [-134.87047034533376, 68.89236035257777],
          [-134.6630786995987, 68.76527084631734],
          [-134.46237492964588, 68.6274852394607],
          [-134.39507573397157, 68.4863954284469],
          [-134.52555303519972, 68.27385905858004],
          [-134.61026458431925, 68.12065213970762],
          [-134.67033130647616, 68.01998013226864],
          [-134.69642647659177, 67.90764371076529],
          [-134.76149574841546, 67.69742465452227],
          [-134.93957242845428, 67.59947578660257],
          [-134.93290087421306, 67.48577873034489],
          [-134.61577674132107, 67.58020599374713],
          [-134.39367950440356, 67.6300859527481]]]),
    cpixel_Masks = ee.ImageCollection("users/jordanffieldsgr/ArcticCarbon/cpixel_Masks_Jun23"),
    geometry = /* color: #d63000 */ee.Geometry.LineString(
        [[-134.93923335592294, 67.01806798535611],
         [-134.96704249898934, 67.00492780617053],
         [-134.99107509176278, 66.99768426333343],
         [-135.0144210390284, 66.99084115825282]]),
    Good_Thiessens = ee.FeatureCollection("users/jordanffieldsgr/ArcticCarbon/Good_Thiessens_3");
/***** End of imports. If edited, may not auto-convert in the playground. *****/
// load pre-generated assets: rivers, segment buffers, and re-defined project area
// this is much faster then attempting to generate them from scratch
//Map.addLayer(MERIT_VF_Ord7, {}, "MERIT STREAMS"); 
//print(MERIT_VF_Ord7);
//print(MERIT_Unioned_Streams, "Merit Unioned Streams");
Map.addLayer(MERIT_Unioned_Streams, {}, "MERIT UNIONED STREAMS"); 
// Map.addLayer(Mack_GT_sites, {}, "GT Sites")
//Map.addLayer(WesternMack_1, {}, 'Western Mack 1'); 
//Map.addLayer(Good_Thiessens, {}, 'Good Thiessens'); 

// TESTING LANDSAT8
//  CODE BLOCK BELOW ONLY NEEDED IF USING LS8:
///////////////////////////////////////////////////////////////////////////////////////////////
/////// LANDSAT 7 and 8 HARMONIZATION (because LS8 has slighlty different band values) ///////
// Code taken from: https://developers.google.com/earth-engine/tutorials/community/landsat-etm-to-oli-harmonization
///////////////////////////////////////////////////////////////////////////////////////////////
	
// Table 2 ELM+ regression coefficients (use these to make LS8 bands in terms of LS7)
var coefficients = {
  itcps: ee.Image.constant([0.0003, 0.0088, 0.0061, 0.0412, 0.0254, 0.0172])
             .multiply(10000),
  slopes: ee.Image.constant([0.8474, 0.8483, 0.9047, 0.8462, 0.8937, 0.9071])
};

//Function to get and rename bands of interest from OLI (LANDSAT 8).
//for old LS8 collecetion, T1_SR
function renameOli(img) {
  return img.select(
    ['B2', 'B3', 'B4', 'B5', 'B6', 'B7', 'pixel_qa'],
    ['Blue', 'Green', 'Red', 'NIR', 'SWIR1', 'SWIR2', 'pixel_qa']);
}

// Transformation function, applies the linear model to OLI data (LANDSAT 8) and
// reattaches the pixel_qa band for later use in cloud and shadow masking.
// original code cast ETM data to signed 16-bit int (toShort()), but I checked
// and all data (TM, ETM+, OLI) seems to be signed 16-bit int already so not going to cast
function OliToEtm(img) {
  return img.select(['Blue', 'Green', 'Red', 'NIR', 'SWIR1', 'SWIR2'])
  .multiply(coefficients.slopes)
  .add(coefficients.itcps)
  .round()
  .addBands(img.select('pixel_qa'));
}

// Define wrapper function to prepare OLI images: 
// consolidates all above functions for convenience in 
// applying them to their respective image collections.
function prepOli(img) {
  var orig = img;
  img = renameOli(img);
  img = OliToEtm(img);
  return ee.Image(img.copyProperties(orig, orig.propertyNames()));
}


//////// HARMONIZATION FOR COLLECTION 2 IMAGES ////////
	
	
// Table 2 ELM+ regression coefficients (use these to make LS8 bands in terms of LS7)
var coefficients = {
  itcps: ee.Image.constant([0.0003, 0.0088, 0.0061, 0.0412, 0.0254, 0.0172])
             .multiply(10000),
  slopes: ee.Image.constant([0.8474, 0.8483, 0.9047, 0.8462, 0.8937, 0.9071])
};

//Function to get and rename bands of interest from OLI (LANDSAT 8).
//For new LS8 collection, T1_L2
function renameOli_new(img) {
  return img.select(
    ['SR_B2', 'SR_B3', 'SR_B4', 'SR_B5', 'SR_B6', 'SR_B7', 'QA_PIXEL'],
    ['Blue', 'Green', 'Red', 'NIR', 'SWIR1', 'SWIR2', 'pixel_qa']);
}


// Transformation function, applies the linear model to OLI data (LANDSAT 8) and
// reattaches the pixel_qa band for later use in cloud and shadow masking.
// original code cast ETM data to signed 16-bit int (toShort()), but I checked
// and all data (TM, ETM+, OLI) seems to be signed 16-bit int already so not going to cast
function OliToEtm_new(img) {
  return img.select(['Blue', 'Green', 'Red', 'NIR', 'SWIR1', 'SWIR2'])
  .multiply(coefficients.slopes)
  .add(coefficients.itcps)
  .round()
  .addBands(img.select('pixel_qa'));
}

// Define wrapper function to prepare OLI images: 
// consolidates all above functions for convenience in 
// applying them to their respective image collections.
function prepOli_new(img) {
  var orig = img;
  img = renameOli_new(img);
  img = OliToEtm_new(img);
  return ee.Image(img.copyProperties(orig, orig.propertyNames()));
}

//////////// END HARMONIZATION CODE ////////////



/// LS8 IMPORT ///
//var ls8 = ee.ImageCollection("LANDSAT/LC08/C02/T1_L2") //new
var ls8 = ee.ImageCollection("LANDSAT/LC08/C01/T1_SR") //old
                                .filter(ee.Filter.bounds(WesternMack_1)) // change this if re-defining project area
                                .filter(ee.Filter.dayOfYear(151,288))
                                .filterMetadata('CLOUD_COVER', 'less_than', 20);
                                
var ls8new = ee.ImageCollection("LANDSAT/LC08/C02/T1_L2") //new
                                .filter(ee.Filter.bounds(WesternMack_1)) // change this if re-defining project area
                                .filter(ee.Filter.dayOfYear(151,288))
                                .filterMetadata('CLOUD_COVER', 'less_than', 20);
print('ls8 Collection 2:', ls8new.limit(10))

//////// CREATE ONE IMAGE COLLECTION USING LS5 and LS7 IMAGES /////////
// Functions to renmae bands in LS5 and LS7 image Collections
// Function to get and rename bands of interest from ETM+ (LANDSAT 7).
function renameEtm(img) {
  return img.select(
      ['B1', 'B2', 'B3', 'B4', 'B5', 'B7', 'pixel_qa'],
      ['Blue', 'Green', 'Red', 'NIR', 'SWIR1', 'SWIR2', 'pixel_qa']);
}

// Define function to prepare ETM+ images.
// works for TM images as well (landsat 5)
function prepEtm(img) {
  var orig = img;
  img = renameEtm(img);
  return ee.Image(img.copyProperties(orig, orig.propertyNames()));
}


//////// MERGING FOR COLLECTION 2 IMAGES ////////
	
	
// Functions to renmae bands in LS5 and LS7 image Collections
// Function to get and rename bands of interest from ETM+ (LANDSAT 7).
function renameEtm_new(img) {
  return img.select(
      ['SR_B1', 'SR_B2', 'SR_B3', 'SR_B4', 'SR_B5', 'SR_B7', 'QA_PIXEL'],
      ['Blue', 'Green', 'Red', 'NIR', 'SWIR1', 'SWIR2', 'pixel_qa']);
}

// Define function to prepare ETM+ images.
// works for TM images as well (landsat 5)
function prepEtm_new(img) {
  var orig = img;
  img = renameEtm_new(img);
  return ee.Image(img.copyProperties(orig, orig.propertyNames()));
}

//// IMPORT IMAGES ////
// using collection 1 (deprecated) instead of collection 2 because we built this before collection 2 existed
// water detection tool is calibrated for collection 1 values
// NOT using LS8 because surface reflectance images are bad/weird
var ls5old = ee.ImageCollection('LANDSAT/LT05/C01/T1_SR')
                                .filter(ee.Filter.bounds(WesternMack_1)) // change this if re-defining project area
                                .filter(ee.Filter.dayOfYear(151,288))
                                .filterMetadata('CLOUD_COVER', 'less_than', 20);
var ls7old = ee.ImageCollection('LANDSAT/LE07/C01/T1_SR')
                                .filter(ee.Filter.bounds(WesternMack_1)) // change this if re-defining project area
                                .filter(ee.Filter.dayOfYear(151,288))
                                .filterMetadata('CLOUD_COVER', 'less_than', 20);
                                
// COLLECTION 2 DATA //
var ls5new = ee.ImageCollection('LANDSAT/LT05/C02/T1_L2')
                                .filter(ee.Filter.bounds(WesternMack_1)) // change this if re-defining project area
                                .filter(ee.Filter.dayOfYear(151,288))
                                .filterMetadata('CLOUD_COVER', 'less_than', 20);
var ls7new = ee.ImageCollection('LANDSAT/LE07/C02/T1_L2')
                                .filter(ee.Filter.bounds(WesternMack_1)) // change this if re-defining project area
                                .filter(ee.Filter.dayOfYear(151,288))
                                .filterMetadata('CLOUD_COVER', 'less_than', 20);
  
//print('Collection 2 LS5 Images:', ls5new.limit(10))
//print('Collection 2 LS7 Images:', ls7new.limit(10))

// Defining function to remove Speckle from water occurence sensing code
var removeSpeckle = function(image){
  var imageSel = image.select(['Green', 'NIR']);
  var replaceNegatives = imageSel.where(imageSel.lt(0), 1);
  var returnImage = image.addBands(replaceNegatives, null, true);
  return returnImage;
  };
  
// Filter OLD collections and prepare them for merging.
var etmCol = ls7old.map(prepEtm);
var tmCol = ls5old.map(prepEtm);
var oliCol = ls8.map(prepOli);

//print('oli', oliCol.limit(10));

// Filter NEW collections and prepare them for merging.
var etmCol_new = ls7new.map(prepEtm_new);
var tmCol_new = ls5new.map(prepEtm_new);
var oliCol_new = ls8new.map(prepOli_new);

// Merge the collections.
var allImages_tm = etmCol
                      .merge(tmCol)
                      .map(removeSpeckle);
var allImages = oliCol
                      .merge(allImages_tm);
                      
// Merge the new collections
// Merge the collections.
var allImages_tm_new = etmCol_new
                      .merge(tmCol_new)
                      .map(removeSpeckle);
var allImages_NEW = oliCol_new
                      .merge(allImages_tm_new);

//print('Collection 2 Images:', allImages_NEW.limit(10))
//print('Collection 2 5&7 Images:', allImages_tm_new.limit(10))
Map.addLayer(allImages_tm_new.first(), {bands:['Red', "Green", "Blue"], min:0, max:20000}, 'Collection 2 LS7')
Map.addLayer(allImages_NEW.first(), {bands:['Red', "Green", "Blue"], min:0, max:20000}, 'Collection 2 LS8')



//////////// STREAM COURSE DATA ////////////////
// Add MERIT_Vectors_Filtered Earth Engine asset to the map
var MERIT = ee.FeatureCollection(MERIT_VF_Ord7); 
// 'VF_Ord7' stands for vectors filtered for lakes (i.e. remove lakes) and retains only rivers of 7th order and greater
//Map.addLayer(MERIT_VF_Ord7, {color: 'blue'}, 'MERIT_VF_Ord7');


/// FUNCTIONS FOR ANALYSIS ///
// Function for masking all pixels in an image except water pixels
// using normalized differences and bitmasks
var waterOnly = function(image){ 
  var land = image.select('SWIR2').lt(500).rename('land');
  var cloudFinal = image.select('Blue').add(image.select('Green'))
      .lt(5000).rename('cloudFinal'); // usually .lt(3500), but not >>ssc, like white r. SD
  // var snowIceFinal = image.select('B3').divide(image.select('B1'))
  //                     .add(image.select('B4').divide(image.select('B1')))
  //                     .gt(1.6)
  var qa = image.select('pixel_qa');
  var bitcloud = qa.bitwiseAnd(1 << 5)
          .and(qa.bitwiseAnd(1 << 7))
          .or(qa.bitwiseAnd(1 << 3));   
          // .or(qa.bitwiseAnd(1 << 4)) 
  
  var snow_ice_qa = qa.updateMask(qa.bitwiseAnd(1 << 4)).rename('snow_ice_qa');
  var snow_ice_qa_b1 = image.select('Blue').lt(2000).rename('snow_ice_qa_b1');
      
  var cloud_qa = qa
      .updateMask(qa.bitwiseAnd(1 << 5)
          .and(qa.bitwiseAnd(1 << 7))
          .or(qa.bitwiseAnd(1 << 3))).rename('cloud_qa');
          
  var nd = image.normalizedDifference(['NIR','Green']);
  
  // save the image's original mask (edges and/or LS7 stripes) for use later
  // can select any band, rename for clarity
  var orig_mask = image.unmask(-1).gte(0).select(["pixel_qa"],["orig_mask"]);
  
  return image.addBands(nd)
              .addBands(ee.Image(1).rename('water'))
              //.updateMask(cloudFinal)
              // .updateMask(snowIceFinal) // this was already commented out
              //.updateMask(land)
              //.updateMask(bitcloud.not())
              .updateMask(nd.lt(0.12)) // previously, threshold of 0
              //.updateMask(snow_ice_qa_b1)
              //.addBands(snow_ice_qa)
              //.addBands(cloud_qa) // not using this
              .addBands(orig_mask)
              .addBands(land)
              .addBands(cloudFinal)
              .addBands(snow_ice_qa_b1);
};

// Function to unmask the image, setting valid non-water pixels = 0 and masking invalid pixels
// invalid pixels are those masked in the original image
var getUnmask = function(image){
  return(image.unmask(0).mask(image.select("orig_mask")));
  };

// MAIN FUNCTION FOR ANALYSIS
// For a given set of years:
// Of all selected images, only select water pixels
// Result is mean water occurrence (1 = always water, 0 = never water)
var getWater_years = function(year){
  var startDate = ee.Date.fromYMD(year, 1, 1);
  var endDate = startDate.advance(2, 'year'); // rolling 2 year time window
    
  // get the right connected pixel mask
  var connectedMask = cpixel_Masks.filter(ee.Filter.eq('year', year)).first(); // only one image should match
 
  var water = allImages
            .filterDate(startDate, endDate)
            .map(waterOnly)       // mask out non-water pixels
            .map(getUnmask)       // unmask the image to set valid non-water pixels = 0
            .select('water')      // select only the water occurrence band
            .mean()            // compute the mean water occurrence for each pixel across all images
            .gt(0.20);         //threshold for % of time (images) that a pixel must be water to be counted as water (added by JF 04/11/23)
  return ee.Image(water
          .updateMask(water) // any pixels that are water in less than X% (currently 20%) of images don't count as water
          //.updateMask(connectedMask) // mask out any lake areas as determined by connected pixels
          .set('start_year',year)
          .rename('water'));
  };
 
 
 ///// NDVI ///// 
//create function to calc NDVI
function NDVI_Calc(image) {
  // Claculate NDVI using normalizedDifference([list of bandname]).rename()
  var NDVI = image.normalizedDifference(['NIR','Red']).rename('NDVI');
  //Add the NDVI band to the image and return
  return image.addBands([NDVI]);
}

var allImages = allImages.map(NDVI_Calc); 

var getNDVI_years = function(year){
  var startDate = ee.Date.fromYMD(year, 1, 1);
  var endDate = startDate.advance(2, 'year'); // rolling 2 year time window
  var meanNDVI = allImages
            .filterDate(startDate, endDate)
            .select('NDVI')
            .mean(); // This returns the mean value of each pixel, not mean for entire image 
  return ee.Image(meanNDVI).set('start_year',year)
}


////////// TROUBLESHOOTING CODE BLOCK ////////////////

var gwy1 = getWater_years(2019);
var gwy2 = getWater_years(2017);

//Map.addLayer(gwy1, {min:0, max:1, palette:['white', 'blue']}, "2020 gwy");
//Map.addLayer(gwy2, {min:0, max:1, palette:['white', 'black']}, "2021 gwy");
//Map.addLayer(ee.Image(cpixel_Masks.filter(ee.Filter.eq('year', 2015)).first()), {min:0, max:1}, '2015 cpixel mask')
//Map.addLayer(newgwy, {}, "new");
//Map.addLayer(oldgwy, {}, "old");
//Map.addLayer(comparison, {}, "comparison")
//Map.addLayer(Thiessen_300m, {}, 'Thiessen Polygons');

// select Thiessen of interest for checking polygons
// point ID 1317861 is 2021 GWY gap at Tsiigehtchic
// point ID 9204664 is original problem zone in cpixel area by large oxbow lake
//var polygon = Good_Thiessens.filter(ee.Filter.eq('point_ID', 2586966)); 
var polygon = ee.Geometry.Point(-111.3941, 56.7411); // fort mcmurray 
//print('selected Thiessen:', polygon); 
//Map.addLayer(polygon, {}, 'Selected Thiessen Poly')
var pool = allImages_tm_new.filterDate('2013-06-01', '2013-12-31') // USING COLLECTION2 IMAGERY HERE, CHANGE BACK TO "allImages" if you want older stuff
                    .filterBounds(polygon)
                    .sort("SENSING_TIME")
print("Fort McMurray gwy image pool: ", pool)

var pool2 = allImages.filterDate('2010-01-01', '2021-01-01')
                    .filterBounds(New_cpixel_AOI)
                    .sort("SENSING_TIME")
//print("GWY image pool in entire cpixel AOI", pool2)

var testimg = ee.Image(pool.first());
var WO_test = ee.Image(waterOnly(testimg));
print(WO_test);
var NDWI = testimg.normalizedDifference(['NIR','Green']);

// find pixels masked out by filters -- take all NDWI water hits, mask out waterOnly hits
// anything remaining would have been water but got filtered out
var WO_mask = WO_test.select('water').unmask().not();
var filtered_out = NDWI.lt(0.35).updateMask(WO_mask);
filtered_out = filtered_out.updateMask(filtered_out); // mask out any areas with NDWI > 0.35

Map.addLayer(testimg, {bands:['Red', "Green", "Blue"], min:0, max:20000}, "test image"); // max:2000 for collection1
Map.addLayer(NDWI, {min:0, max:1, palette:['white', 'blue']}, 'NDWI');

// for these three, black = pixel will be masked out by filter
Map.addLayer(WO_test.select('land').updateMask(WO_test.select('land').not()),
  {min:0, max:1, palette:['black', 'green']}, 'land mask'); // masked for SWIR2 > 500
Map.addLayer(WO_test.select('cloudFinal').updateMask(WO_test.select('cloudFinal').not()),
  {min:0, max:1, palette:['black', 'green']}, 'cloud mask'); // masked for blue + green > 5000
Map.addLayer(WO_test.select('snow_ice_qa_b1').updateMask(WO_test.select('snow_ice_qa_b1').not()),
  {min:0, max:1, palette:['black', 'green']}, 'snow/ice mask'); // masked for blue > 2000

Map.addLayer(NDWI.lt(0.35).updateMask(NDWI.lt(0.35)), {min:0, max:1, palette:['white', 'blue']}, 'NDWI mask'); // blue = NDWI < 0.35, not masked
Map.addLayer(filtered_out, {min:0, max:1, palette:['black', 'green']}, "filtered pixels"); // cumulative effects of all filters
Map.addLayer(WO_test.select('water'), {min:0, max:1, palette:['black', 'red']}, 'waterOnly');



// Map.addLayer(ee.Image(pool.filter(ee.Filter.eq("LANDSAT_ID", "LE07_L1TP_062013_20210615_20210712_01_T1")).first()),
//     {bands:['Red', "Green", "Blue"], min:0, max:2000}, "LS7 6/15 dup1");
// Map.addLayer(ee.Image(pool.filter(ee.Filter.eq("LANDSAT_ID", "LE07_L1TP_062012_20210615_20210712_01_T1")).first()),
//     {bands:['Red', "Green", "Blue"], min:0, max:2000}, "LS7 6/15 dup2");

// run waterOnly on the 2015 and 2016 images
var im2015 = ee.Image(waterOnly(allImages.filterDate('2015-01-01', "2016-01-01").filterBounds(polygon).first()).select('water'))
var im2016 = ee.Image(waterOnly(allImages.filterDate('2016-01-01', "2017-01-01").filterBounds(polygon).first()).select('water'))
//Map.addLayer(im2015, {min:0, max:1, palette:['black', 'red']}, "2015 image waterOnly")
//Map.addLayer(im2016, {min:0, max:1}, '2016 image waterOnly')
// 2016 image isn't detecting well
// Map.addLayer(allImages.filterDate('2015-06-01', "2017-07-01").filterBounds(polygon).first(),
//           {bands:['Red', "Green", "Blue"], min:0, max:2000}, "2015 landsat8 image")
// Map.addLayer(allImages.filterDate('2015-07-01', "2015-07-02").filterBounds(polygon).first(),
//           {bands:['Red', "Green", "Blue"], min:0, max:2000}, "2015 landsat7 image")

// save GWY images
Export.image.toAsset({image:gwy1.clip(WesternMack_1), description:"2019getWateryears-30m", maxPixels:2e10, scale:30});
Export.image.toAsset({image:gwy2.clip(WesternMack_1), description:"2017getWateryears-30m", maxPixels:2e10, scale:30});

// load in GWY image assets for visual checks

// 150m/pixel scale
var gwy2021_150m = ee.Image("users/jekreisler/mackenzie/2021getWateryears-150m");
var gwy2020_150m = ee.Image("users/jekreisler/mackenzie/2020getWateryears-150m");
var gwy2019_150m = ee.Image("users/jekreisler/mackenzie/2019getWateryears-150m");
var gwy2018_150m = ee.Image("users/jekreisler/mackenzie/2018getWateryears-150m");
var gwy2017_150m = ee.Image("users/jekreisler/mackenzie/2017getWateryears-150m");
var gwy2012_150m = ee.Image("users/jekreisler/mackenzie/2012getWateryears-150m");

// 100m/pixel scale
var gwy2021_100m = ee.Image("users/jekreisler/mackenzie/2021getWateryears-100m");
var gwy2020_100m = ee.Image("users/jekreisler/mackenzie/2020getWateryears-100m");
var gwy2019_100m = ee.Image("users/jekreisler/mackenzie/2019getWateryears-100m");
var gwy2018_100m = ee.Image("users/jekreisler/mackenzie/2018getWateryears-100m");
var gwy2017_100m = ee.Image("users/jekreisler/mackenzie/2017getWateryears-100m");
var gwy2012_100m = ee.Image("users/jekreisler/mackenzie/2012getWateryears-100m");

// 30m/pixel scale
var gwy2017_30m = ee.Image("users/jordanffieldsgr/ArcticCarbon/2017getWateryears-30m");
var gwy2019_30m = ee.Image("users/jordanffieldsgr/ArcticCarbon/2019getWateryears-30m");
var gwy2021_30m = ee.Image("users/jordanffieldsgr/ArcticCarbon/2021getWateryears-30m");

Map.addLayer(gwy2021_30m, {min:0, max:1}, "GWY 2021");
// Map.addLayer(gwy2017_30m, {min:0, max:1}, "GWY 2017");
// Map.addLayer(gwy2019_30m, {min:0, max:1}, "GWY 2019");
// Map.addLayer(gwy2018, {min:0, max:1}, "GWY 2018");
// Map.addLayer(gwy2017, {min:0, max:1}, "GWY 2017");
// Map.addLayer(gwy2012, {min:0, max:1}, "GWY 2012 150 m");

///////////////// RIVER LENGTH EXPORT ///////////////////////////////////////
//JFF trying to get stream length in each polygon below

// filter out the bad polygon
var filter_bad_out = ee.Filter.eq("point_ID", 8492024).not() // keeps all polys except that one

// checking to make sure the filter works correctly
// print(Good_Thiessens.size());
// print(Good_Thiessens.filter(filter_bad_out).size())
// print(Good_Thiessens.filter(filter_bad_out).filter(ee.Filter.eq("point_ID", 8492024)))

var Good_Thiessens_test = Good_Thiessens
  //.limit(100) // for testing
  .filter(filter_bad_out)
  .map(function(feature){
    // All river segments overlapping with polygon
    var lines_sel = MERIT_Unioned_Streams
                      .filterBounds(feature.geometry())
                      
    var line_lengths = lines_sel.map(function(feature_2){
      var length_sel = feature_2.geometry().intersection(feature.geometry()).length()
      return feature.set('length_m',length_sel.int16())
    })
    
    var all_lengths = line_lengths.sort('length_m',false).first()
    
    return feature.set('length_m',all_lengths.get('length_m'))
  })

//var testpolys = Good_Thiessens.limit(10);
//Map.addLayer(testpolys, {}, "test polys");

// var single = ee.Feature(testpolys.first());
// var bad_one = ee.Feature(Good_Thiessens.filter(ee.Filter.eq('point_ID', 1775204)).first())
// //print(single);
// print(Good_Thiessens.filter(ee.Filter.eq('point_ID', 1775204)))
// print(bad_one, "bad one")
// Map.addLayer(bad_one, {}, "one poly");
// var stream_overlap = MERIT_Unioned_Streams.filterBounds(single.geometry());
// print(stream_overlap);
// Map.addLayer(stream_overlap, {}, "intersecting streams");
// var intersected = ee.Feature(stream_overlap.first()).intersection(single);
// print(intersected);
// Map.addLayer(intersected, {}, "intersection");
// print(intersected.length())

//print(geometry.length()); // how long is the real distance (roughly)?

//Find Thiessen that Doesn't intersect streamline
// create a filter
var filterInside = ee.Filter.bounds(MERIT_Unioned_Streams);
var filterNot = filterInside.not();
var badOne = ee.Filter.eq('point_ID', 1775204); // this Thiessen has no line and yet it is not the problem, so something else going on
// note -- I don't think that is the problem Thiessen
var goodOnes = badOne.not(); 

var wLines = Good_Thiessens.filter(filterInside);
var testGood = Good_Thiessens.filter(goodOnes); 
var noLines = Good_Thiessens.filter(filterNot);
//Map.addLayer(noLines, {}, "bad bad bad boy") // SW corner of lake athabasca
//print('Thiessens With Lines:', wLines.size()) // 2717 have lines
//print('Thiessens Without Lines:', noLines); //1 doesn't have a line
//print('Total Good_Thiessens:', Good_Thiessens.size()); // 2718 total, so math adds up
//print('The Thiessen without a Line:', noLines.first()); 
  
Export.table.toAsset({
  collection: Good_Thiessens_test,
  //folder: 'ArcticCarbon',
  description: 'Good_Thiessens_test',
  assetId: 'Good_Thiessens_3',
});

// Export.table.toDrive({
//   collection: Good_Thiessens,
//   folder: 'ARCTIC_CARBON',
//   description: 'Good_Thiessens',
//   fileNamePrefix: 'Good_Thiessens_REAL',
//   fileFormat: 'CSV'
// });


///////////////////// END RIVER LENGTH EXPORT ////////////////////////////////////


////////// END TROUBLESHOOTING CODE BLOCK ////////////////


//// PERFORM ANALYSES ////
//// CALCULATE WATER OCCURRENCE FOR SELECTED FIVE-YEAR PERIODS ////

// Construct list 1985-2020 -- all years for which we have data
var waterYear = ee.List.sequence(1985,2020,1);
// Select water pixels for each year
var waterYear_long = ee.ImageCollection(waterYear.map(getWater_years));
var ndviYear_long = ee.ImageCollection(waterYear.map(getNDVI_years)); 

// Map.addLayer(waterYear_long, {}, "waterYear_Long")
// print(waterYear_long)

// Select water pixels for each year starting in 1990
// we will later do area calculations over a 5 year span, so can't
// perform the first calculation until 1990, when we have 5 years of data
var waterYear_short = waterYear_long.filter(ee.Filter.gte('start_year', 1990));
var ndviYear_short = ndviYear_long.filter(ee.Filter.gte('start_year', 1990)); 
//print('NDVI Image Short Collect:', ndviYear_short.limit(10));

// Subtract water occurence of earlier year from more recent year
// results in map of area that changed between land and water
 var getareaChange = function(image){
   var year_sel = ee.Number(image.get('start_year'));
   var year_pre = year_sel.subtract(5);
   var pre_image = ee.Image(waterYear_long
        .filterMetadata('start_year', 'equals', year_pre)
        .first());
   var pre_land = pre_image.gt(0).unmask(0).eq(0);
   var landLost = image.updateMask(pre_land);
   var post_land = image.gt(0).unmask(0).eq(0);
   var landGained = pre_image.updateMask(post_land); 
   return ee.Image(landLost).rename('Land Lost')
                            .addBands(landGained.rename('Land Gained'))
                           // .addBands(image); // added this 6/22/23 to preserve water band; so 'image' is water in the end of the
                                              // 5yr window (i.e. it is 1990 water for the 1985-1990 period). We use water from the 
                                              // start of the period to normalize so we want to save 'pre_image' here potentially. 
   };

// Generate water occurence difference for each range of years
var mappedArea =  waterYear_short.map(getareaChange);
//print(mappedArea); 

// filter thiessen polygons for project AOI to exclude unwanted polys (covering lake areas)
var thiessen_polys = Good_Thiessens.filterBounds(WesternMack_1);
//Map.addLayer(thiessen_polys, {}, 'Good Thiessens'); 
//print('Thiessens:', thiessen_polys);

// Function to count quantity of area change for an image that is a map of area change
// returns feature collection with area lost/gained in each, along with 'MERIT Hydro' raster properties 
/////// NOTE: WHEN RUNNING FOR 'Total Water Area' COMMENT OUT THE AREA LOST/GAINED PROPERTIES HERE AND REMOVE 
/////// THOSE PARAMETERS FROM THE 'GET_EXPORT_PROPS' FUNCTION
var areaCount = function(image){
  var start_year = image.get('start_year');
  var reduced = image.reduceRegions({
      reducer: ee.Reducer.count(),
      collection: thiessen_polys, 
      scale: 30,
      crs: 'EPSG:32610'
    });
    return reduced.map(function(feature){ // map function to generate properties over each image
      return ee.Feature(feature)
                                .set('start_year', start_year) // For 1990 - 1985, 1990 is the start year
                                .setGeometry(null)
                                .set('latitude', feature.geometry().centroid().coordinates().get(1))
                                .set('longitude', feature.geometry().centroid().coordinates().get(0))
                                .set('Water_Area_km2', ee.Number(feature.get('count')).multiply(0.0009))
                                //.set('area_lost_km2', ee.Number(feature.get('Land Lost')).multiply(0.0009))
                                //.set('area_gained_km2', ee.Number(feature.get('Land Gained')).multiply(0.0009))
                                .set('Polygon_Area_km2', feature.get('Area_km2'))
                                .set('Stream_Order', feature.get('mean'))
                                .set('Flw_Dir', feature.get('dir'))
                                .set('Elv', feature.get('elv'))
                                .set('Thiessen_ID', feature.get('point_ID'))
                                .set('Upstream_Area_km2', feature.get('upa'))
                                .set('Upstream_pix', feature.get('upg'))
                                .set('Hydro_Adj_Elv', feature.get('hnd'))
                                .set('Width', feature.get('wth'))
                                //.set('Length_m', feature.get('length_m'));
                
    });
};


// function to select desired properties for export
var get_export_props = function(feature) {
  return ee.Feature(feature.select(['start_year', 'Water_Area_km2', 'Polygon_Area_km2', 'latitude', 'longitude', 
                                    'Stream_Order', 'Flow_Dir', 'Elv', 'Thiessen_ID', 'Upstream_Area_km2', 
                                    'Upstream_pix', 'Hydro_Adj_Elv', 'Width']));
};

// IMPORTANT: put this in the list above and take out 'area lost/gained' when running/exporting for total water area
// , 'area_lost_km2', 'area_gained_km2',

///////////// Calculate PIXELS LOST/GAINED by segment over all years, flatten output, select properties /////////////
var pixelsChanged = ee.FeatureCollection(mappedArea.map(areaCount)).flatten();

// get rid of this step?
var pixelsChanged_to_export = pixelsChanged.map(get_export_props);

//////////// Calculate TOTAL AREA covered by water by segment over all years ////////////////
var totalArea = ee.FeatureCollection(waterYear_long.map(areaCount)).flatten();

var totalArea_to_export = totalArea.map(get_export_props);




////// NDVI FUNCTIONS //////

//
 var getNDVI_Change = function(image){
   var year_sel = ee.Number(image.get('start_year'));
   var year_pre = year_sel.subtract(5);
   var pre_image = ee.Image(ndviYear_long
        .filterMetadata('start_year', 'equals', year_pre)
        .first());
   var ndviChange = image.divide(pre_image); // making a ratio of later NDVI over earlier NDVI:
   // 0-1 means browning; 1 means no change; >1 means greening
   return ee.Image(ndviChange).rename('NDVI Ratio').set('Year', year_sel); 
 };
 
// Generate water occurence difference for each range of years
var ndviDiff =  ndviYear_short.map(getNDVI_Change);
//print('NDVI Diff', ndviDiff.limit(10)); 

// Function to get mean NDVI value in each Thiessen Polygon
// returns feature collection with NDVI Ratio in each, along with 'MERIT Hydro' raster properties 
var ndviReduce = function(image){
  var Year = image.get('Year');
  var reduced = image.reduceRegions({
      reducer: ee.Reducer.mean(),
      collection: thiessen_polys, 
      scale: 30,
      crs: 'EPSG:32610'
    });
    return reduced.map(function(feature){ // map function to generate properties over each image
      return ee.Feature(feature)
                                .set('Year', Year) // For 1990 - 1985, 1990 is the start year
                                .setGeometry(null)
                                .set('latitude', feature.geometry().centroid().coordinates().get(1))
                                .set('longitude', feature.geometry().centroid().coordinates().get(0))
                                .set('NDVI', ee.Number(feature.get('mean')))
                                .set('Polygon_Area_km2', feature.get('Area_km2'))
                                .set('Stream_Order', feature.get('mean'))
                                .set('Flw_Dir', feature.get('dir'))
                                .set('Elv', feature.get('elv'))
                                .set('Thiessen_ID', feature.get('point_ID'))
                                .set('Upstream_Area_km2', feature.get('upa'))
                                .set('Upstream_pix', feature.get('upg'))
                                .set('Hydro_Adj_Elv', feature.get('hnd'))
                                .set('Width', feature.get('wth'))
                                //.set('Length_m', feature.get('length_m'));
                
    });
};

// function to select desired properties for export
var get_export_props = function(feature) {
  return ee.Feature(feature.select(['Year', 'NDVI', 'Polygon_Area_km2', 'latitude', 'longitude', 
                                    'Stream_Order', 'Flow_Dir', 'Elv', 'Thiessen_ID', 'Upstream_Area_km2', 
                                    'Upstream_pix', 'Hydro_Adj_Elv', 'Width']));
};

// Calculate change in NDVI by segment over all years, flatten output, select properties
var ndviData = ee.FeatureCollection(ndviDiff.map(ndviReduce)).flatten();
//print('NDVI Data:', ndviData.limit(10)); 

// Map export Properties fxn
var ndviExport = ndviData.map(get_export_props);

/////////////// ALL EXPORTS ////////////////////

// Export area lost to drive
//   Export.table.toDrive({
//   collection: pixelsChanged_to_export,
//   folder: 'ARCTIC_CARBON',
//   description: 'AreaChanged1990_2020', // to calculate a different year range
//                                           // you change waterYear_short  
//   fileNamePrefix: 'AreaChanged1990_2020_vJun29_23',
//   fileFormat: 'CSV'
// });



//Export Total Water Area
Export.table.toDrive({
  collection: totalArea_to_export,
  folder: 'ARCTIC_CARBON',
  description: 'TotalArea1985_2020',
  fileNamePrefix: 'TotalArea1985_2020_Jul24_23',
  fileFormat: 'CSV'
});


//Export NDVI Ratio for each Thiessen Polygon
Export.table.toDrive({
  collection: ndviExport,
  folder: 'ARCTIC_CARBON',
  description: 'ndviRatio_1990_2020',
  fileNamePrefix: 'ndviRatio_1990_2020_Aug02_23',
  fileFormat: 'CSV'
});


// Calculate total area of Thiessen Polygons (MODIFY)
// var thiessenArea = ee.FeatureCollection(Good_Thiessens.map(areaCount)).flatten();
// var totalArea_to_export = totalArea.map(get_export_props);

/////////////// END EXPORTS ////////////////////


 // This if we want to look at vegetated AREA over time, but I am just going to look at raw NDVI over time for now
/*
///// NDVI ///// 
// Calculate NDVI at each thiessen polygon
var vegOnly = function (image) {
  var water = image.normalizedDifference('NIR','Green').lt(0);
  var cloudFinal = image.select('Blue').add(image.select('Green'))
      .lt(5000); // usually .lt(3500), but not >>ssc, like white r. SD
  // var snowIceFinal = image.select('B3').divide(image.select('B1'))
  //                     .add(image.select('B4').divide(image.select('B1')))
  //                     .gt(1.6)
  var qa = image.select('pixel_qa');
  var bitcloud = qa.bitwiseAnd(1 << 5)
          .and(qa.bitwiseAnd(1 << 7))
          .or(qa.bitwiseAnd(1 << 3));   
          // .or(qa.bitwiseAnd(1 << 4)) 
  
  var snow_ice_qa = qa.updateMask(qa.bitwiseAnd(1 << 4)).rename('snow_ice_qa');
  var snow_ice_qa_b1 = image.select('Blue').lt(2000);
      
  var cloud_qa = qa
      .updateMask(qa.bitwiseAnd(1 << 5)
          .and(qa.bitwiseAnd(1 << 7))
          .or(qa.bitwiseAnd(1 << 3))).rename('cloud_qa');
          
  var NDVI = image.normalizedDifference(['NIR','Red']).rename('NDVI');
  
  // save the image's original mask (edges and/or LS7 stripes) for use later
  // can select any band, rename for clarity
  var orig_mask = image.unmask(-1).gte(0).select(["pixel_qa"],["orig_mask"]);
  
  return image.addBands(NDVI)
              .addBands(ee.Image(1).rename('Vegetation'))
              .updateMask(cloudFinal)
              .updateMask(bitcloud.not())
              .updateMask(water) // threshold of 0
              .updateMask(snow_ice_qa_b1)
              .addBands(snow_ice_qa)
              .addBands(cloud_qa)
              .addBands(orig_mask);
};


// NDVI Calculation
// For a given set of years:
// Of all selected images, only select water pixels
// Result is mean water occurrence (1 = always water, 0 = never water)
var getVeg_years = function(year){
  var startDate = ee.Date.fromYMD(year, 1, 1);
  var endDate = startDate.advance(2, 'year'); // rolling 2 year time window
    
  // get the right connected pixel mask
  var connectedMask = cpixel_Masks.filter(ee.Filter.eq('year', year)).first(); // only one image should match
  // keeping this mask to mask out lakes still 
 
  var Veg = allImages
            .filterDate(startDate, endDate)
            .map(vegOnly)       // mask out non-water pixels
            .map(getUnmask)       // unmask the image to set valid non-water pixels = 0
            .select('vegetation')      // select only the water occurrence band
            //.mean()            // compute the mean vegetation occurrence for each pixel across all images
            // do we need to take mean here, outliers are ok, unlike high flows with water 
            
  return ee.Image(vegetation
          .updateMask(vegetation) // any pixels that are water in less than X% (currently 20%) of images don't count as water
          .updateMask(connectedMask) // mask out any lake areas as determined by connected pixels
          .set('start_year',year)
          .rename('vegetation'));
  };
*/








/// OLD ATTEMPTS TO INCLUDE 1984 AND 2021 IN ANALYSIS ///

/*
// duplicate 2020 connected pixel image to use for 2021 as well
// since 2021 images are limited
var cpixel2021 = ee.Image(connected_collection.filter(ee.Filter.eq('year', "2020")).first())
                          .set("year", "2021");
Map.addLayer(cpixel2021, {}, 'CPX_2021') // this looks bad, not filtering lakes out

var cpixel2010 = ee.Image(connected_collection.filter(ee.Filter.eq('year', "2010")).first())
Map.addLayer(cpixel2010, {}, 'CPX_2010') // JF TESTING

//1984 cpixel image was generated after all the others, so is loaded separately 
var cpixel1984 = ee.Image("users/jekreisler/mackenzie/proj_out_1984");

// alternatively, if we can't get a good 1984 connected pixel image
var cpixel1984 = ee.Image(connected_collection.filter(ee.Filter.eq('year', "1985")).first())
                          .set("year", "1984");

// either way, then do this
var extraImages = ee.ImageCollection([cpixel2021, cpixel1984]);
connected_collection = connected_collection.merge(extraImages);
print(connected_collection)
*/


/// TESTING CODE to confirm that ls7 stripes are excluded correctly ///
/*
var ls5img = allImages.filter(ee.Filter.date("1997-01-01", "1998-01-01")).filterBounds(lat67).first();
var testmask = ls5img.unmask(-1).gte(0).select(["pixel_qa"],["orig_mask"]);

ls5img = ls5img.addBands(testmask);
ls5img = ls5img.unmask(0).mask(ls5img.select("orig_mask"));
Map.addLayer(ls5img, {bands:["Red", "Green", "Blue"], min:0, max:800}, "ls5");
Map.addLayer(testmask, {}, "edge mask")

///////////////////////////////
// TESTING CODE
//////// /////// ///// ///////
// check outputs from areaCount -- JORDAN this is the testing code
// set up test getWater_years image
var testgwy = getWater_years(2010)
print("get water years image: ", testgwy);

// put test image through getareaChange -- important to check output bands
var test_area_map = getareaChange(testgwy);
print("area change map image: ", test_area_map)

// set up and check test polygons -- what properties do they have?
thiessen_polys = Good_Thiessens.limit(10);
print("test thiessen polys: ", thiessen_polys);

// test reduceRegions and check output -- are all desired properties present and names correct?
var reduce_test = test_area_map.reduceRegions({
      reducer: ee.Reducer.count(),
      collection: thiessen_polys, 
      scale: 30,
      crs: 'EPSG:32610'});
print("reduce regions test: ", reduce_test);

/// if you are satisfied with all of the above, the code should be ok ///
*/